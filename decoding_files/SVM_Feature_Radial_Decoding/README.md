# How does this decoder work?

### Searches, drops, and scoring
This decoder utilizes feature-based symmetrical radial searches to identify the best set of spots in an unbiased fashion. First the algorithm begins by performing a nearest neighbor radial search for each spot (ignoring spots within the same barcoding round), where the distance in pixels is defined by the user, using each barcoding round as reference (termed seeds). Searches are performed by comparing each round to the other individual rounds in a parallel fashion. If multiple spots fall within the search radius of a given reference spot, then each spot will be assigned a score based on distance, intensity, and size. The highest scoring spot will be chosen and an overall codeword score will be assigned after picking the best spot for each barcoding round. These scores (including the overall codeword score) will be influenced by the number of total neighbors encountered. Each codeword will also be assigned an ambiguity score, which is the total number of additional neighbors found over the expected for each seed. Additionally, each spot is assigned a probability score on the liklihood that the spot corresponds to a true barcode based on its features using an SVM model. The probability score and the codeword score is used to generate the overall score for each decoded barcode (look at scoring_scheme.pdf for more info).  If a parity round is incorporated, then a drop in spot call from any of the barcoding rounds is kept (this is referring to diff=1). The supplied codebook will be altered automatically for proper assignment of spots with error correction.

### Min seed filtering, clashing codeword picking, and parity check
Once the best set of spots are chosen, they are further filtered based on the number of times the same set of spots were picked when changing barcoding round reference (termed min seed). The min seed criteria can be used to increase stringency when decoding. Spot sequences that have passed the min seed criteria will then be further checked to make sure that certain spots are used only once. If there are any codewords that have similar spots picked, then their overall codeword score will be used to pick the best one. If they have the same score, then the codeword that had the smallest total distance between spots will be used. Finally, if there is a parity round, then a parity check will be performed on the codeword. If the codeword does not have proper parity, then it will be marked as "undefined" since it is truly ambiguous and we cannot distinguish the signal as on or off (the include undefined argument will return locations of spots that didn't pass parity). At this point, we have treated every spot the same and do not have any knowledge on whether they are on or off-target codewords. A hash table (generated from the codebook) that contains both on and off codewords is used to assign the gene name to the best picked spot set. 

### Multi-round decoding
Unused spots are then resubmitted for an additional round of decoding (up to 3) to try and assign left over spots. The decoder also has an option to decode the top 10% of highly expressed gene in a given field of view in the first round of decoding to reduce spot density. 
